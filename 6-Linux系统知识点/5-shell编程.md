### 一、Shell脚本简介

一般是以 `.sh` 扩展名的文本文件，建议不要省略扩展名。

为了能够对服务器的批量执行操作，可以将执行的命名写入文件，批量执行，这种文件就是称为 `脚本`

### 二、创建shell脚本流程

+ `touch  test.sh`   ==>创建 test.sh  脚本文件 

+ vim test.sh     ==>编写脚本内容，使用vim编辑器

  + 脚本内容的第一行：通过注释指明执行脚本的程序 `#!开头`

    + `#!/bin/sh`
  + `#!/bin/bash`   ==>大多数是利用这种
    
    + `#!/usr/bin/env bash`
    
  + 查询命令在哪个位置-->`which 命令`

  + ```
    第一行： #！/bin/bash	 ==>告诉终端使用哪些程序来执行
    
    //下面是指python中的脚本
    第一行： #!/usr/bin/env python   ==>告诉终端使用哪些程序来执行
    
    export A=123   //定义全局变量， 
    ```

+ 让该脚本能够执行

  + 执行脚本之前需要**给与执行权限**
  + `chmod a+x test.sh`
  + 终端输入：`./test.sh `  
  + `echo $?`  ==>**返回上一次**程序退出的状态码 (0指的是正常退出状态码)
    - 可以看程序是否正常，可以通过状态码观察（通过一些插件如果状态码是0正常，其他的状态码的出现小红叉）
    - 比如：netstat -natp | grep 127    ==>找得到，状态码为 0
      - 如果匹配其他的字符找不到的话，返回异常状态码
  + echo  ”abc\ndef“    ==>不会换行
  + echo -e  ”abc\ndef“     ==>加个 -e  换行
  
  + 将该脚本文件放到用户的bin中即 `usr/local/bin/ `目录下，

### 三、定义变量

+ **如何设置变量**

  - 比如 a = 12345  ==>会报错，没有找到命令，**= 前后没有空格**

  - `定义变量： a=12345`

  - 查看变量：`echo $a `   == >需要加个 **$**符号

  - 使用变量：`echo “a is $a” `   ==> a is 12345

    - **单引号**：里面内容会**按照原样输出**
    - **双引号**：如果有**$会转为对应变量的值**

  - 利用 `expr`  可进行变量的运行（ + 、-）

    - ```
      a=123
      b=456
      expr $a + $b   ==> 123+456
      ```

    - 利用 **$[]**   进行高级运算

      - ```
        echo $[$a * $b]   ==>只有在[] 以数字的形式运算，其他情况是变量的拼接
        ```

+ **全局变量**

  + `export A=123`   定义当前Shell全局变量（在脚本中编辑的）

  + `source  脚本`   ==>终端重新加载脚本,才可以使用

+ **常用的系统环境变量**

  + `echo  $PATH`  可执行文件的目录
  + `echo $PWD`  当前的目录
  + `echo $HOME` 目录
  + `echo $USER`  当前用户名
  + `echo $UID`  当前用户的uid

+ `whoami ` 查看当前用户名

### 四、if 语句

+ 格式

```
if 命令
then 
	语句1
elif 命令
then
	语句2
else
	上面都不满足执行语句3
fi  ==> fi 结束标志
```

方式1：if 语句 检查的是 其**后面跟的命令** 的 状态码  是否**为 0(True)、 不为0(都为False)**

方式2：if 语句  后面跟 `[……]` 条件测试命令**，注意**：[ ] 注意内容使用空格与 [ 、] 分隔，不让会被认为 整个是 命令。

+ 比如：

```
//终端的输入
if [ -f test.sh ]  ==> 当前目录下需要有tesh,sh 文件 回车，会得到 > 继

//脚本中编写，分号是用做拼接成一行使用的。平常可以忽略
if [ -f abc.md ];   // 注意if 后面需要空格，中括号也是命令(-f 是前半中括号的参数)，是个测试命令，中括号里面内容前后都需要空格，不然会认为整体为一个命令
then   // 如果
	echo 'it is a file';
else
	echo 'it is not a file';
fi  

//把if后面改成  if ls abcd;   ==> 意思：ls是命令，查看ls有没有abcd文件

if后面是判断状态码是否为正常，如果为0，执行then中语句，否则执行else

```

+ 数值比较
  + `[ n1 -eq n2 ]`   ==> 判断n1 与 n2 是否相等、
  + 同理 `-ge`大于或等于、`-gt`大于、`-le`小于或等于、`-lt`小于、`-ne`不等于

```
//实例：
a=123
b=123
[ $a -eq $b]; echo $?    ==>成立返回0，否则返回1
如果我想直接输入符号，那么需要在加个[]，如果不加会认为是字符串比较
[[ $a == $b ]];echo $?
```

+ 字符串比较

  + `=` 是否相等、`!=`不相等、`<`、`>`、`-n`检查长度是否不为0、`-z`检查长度是否为0
  
  ```
  //实例
  a='qwer'
  b='qwer'
  c='poiu'
  [ $a = $b ];echo $?
  
  [ $a > $c ];echo $?  ==> 0  ，按照ASCII值
  
  [ -n $a ];echo $?  ==> -n检查该字符串是否为 非空
  [ -z $a ];echo $?  ==> -z检查该字符串的是否为 空 0 z指zero
  ```
  
  + 注意：![1567389038704](C:\Users\msi\AppData\Roaming\Typora\typora-user-images\1567389038704.png)
  + 上面如果不使用 **\ 转义字符**的话那么，会把> 、< 理解成重定向的来。所以需要  转义字符 \
  + 如果不使用转义字符的话，那么在使用  [] 包裹起来。
    + `[[  $a  >  $b ]] ；echo $? `    返回 1  
  
+ 文件的比较

  + `-d`是否存在并且是一个目录、`-e`是否存在、`-f`是否存在并且为一个文件、`-r`是否可读、`-w`是否可写、`-x`是否执行、`-s`是否非空、`-O`是否属于当前用户、`-G`默认组与当前组是否相同、`-nt`比较前者是否比后者新、`-ot`比较前者是否比后者旧

  ```
  [ -d $1 ];echo $?   ==>如果我传的是个文件夹，那么返回0，否则返回1。
  同理其他的语句
  ```

  

### 五、循环语句

+ for 语句

```
for i in `seq 1 10`    //seq 和 python中的range，不同的是双闭区间
do  // 开始标志
	echo $i   //产生1-10数字，包含1
done  //结束标志

判断是否为偶数
for i in `seq 1 10`
do 
	if
```

```
for ((i=0;i<10;i++))   //双层小括号，里面就不需要$符号了，i也不要声明
do 
	echo $i
done
```

### 六、函数 function

``` 
//定义函数
function foo(){   （）都为空
	echo 'i am foo'
}
foo     //函数调用，不需要括号

//如果里面不写foo调用函数，在外部调用应该如何操作？
需要在终端 
source 脚本文件   ==>相当于python中import    . 也可以代替source
foo   直接在终端就可以直接调用了
```

```
如何传参数？
function foo(){
	
	echo "第0个参数 $0"  //如果foo 该参数为 bash 、如果 ./test.sh 参数为./test.sh（因为这个是脚本的本身调用的）  $0就是调用者的本身
	echo "第一个参数 $1"
	echo "第二个参数 $2"
	echo "第三个参数 $3"
	
	#得到全部参数
	echo "全部参数：$*"   ==>星号
	echo "全部参数: $@"  ==> @ 号  两者是等效的
	
	echo "一共有 $# 个参数"  ==># 得到参数数量
}

foo 111 222 333 444 555 666    

//以下是脚本本身的参数，并不是函数的参数
echo "第一个参数 $1"
echo "第二个参数 $2"
echo "第三个参数 $3"
	
#得到全部参数
echo "全部参数：$*"   ==>星号
echo "全部参数: $@"  ==> @ 号  两者是等效的
	
echo "一共有 $# 个参数"  ==># 得到参数数量


外部：
. test.sh
foo aa bb cc dd ee ff   ==>foo参数是和命令一样的，这里传递了6个参数


如果使用脚本本身调用，传参数能传参数么？ （脚本本身的参数没有函数包裹的）
./test/sh xx yy zz   ==>接收不到


```

注意：在脚本中没有写函数的调用，那么在外部需要，重载，直接就可以调用的。（此时的重载不必要传参数）调用时传参数。

在脚本中有函数的调用，那么在外部 重载时，要给函数加参数。（./脚本  说明是在脚本中执行，如果里面需要传值，直接在重载后面的传值  ./脚本 xxx yyy ）脚本的本身不是写在函数里面的。

+ **如何获取用户的输入**
  + `read  -p  '请输入一个数字：'  num `    ==> -p 是提示语句
  + echo  '您的输入：$num ' 

练习1-判断两个文件是否相等(利用md5)

```
//test.sh
#!/bin/bash
function check(){
	s1=`md5sum $1 | awk '{print $1}'`
	s2=`md5sum $2 | awk '{print $1}'`
	if [ s1 = s2 ]
	then 
		echo "两个文件一致"
	else
		echo "两个文件不一致"
	fi
}
//终端操作
source test.sh
check 文件1 文件2    //调用函数并没有在脚本中。   
//也可以不定义函数，
```

